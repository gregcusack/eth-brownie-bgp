pragma solidity ^0.8.0;
pragma experimental ABIEncoderV2;
contract IANA {

    string public name = "IANA base contract"; //stored on BC
    address public owner; //IANA

    struct IPPrefix {
        uint32 ip;
        uint8 mask;
        uint32 owningAS;
        uint[] subPrefixes; // Pointer to prefix index in the larger prefixes array.
    }

    struct ASResource {
        uint32 ASN; //not sure if should be ASN or name of AS
        string RIR; // ARIN, AFRINIC, etc
        string owner; //RIR, NIR, LIR
        uint stime; //start time
        uint vperiod; //period. or end time?? 
    }

    enum IPState {
        Unregistered,
        Registered,
        Allocated,
        Assigned,
        Binded
    }

    struct IPResource {
        IPPrefix prefix;
        IPState state;
        string RIR;     // authority -> ISP. could be RIR -> NIR -> ISP but leaving out for now
        // string xIR;     // authority2, rir, nir, lir
        string owner;   // ISP
        string leasee;  // 
    }


    // All the people who can change the function pointers
    mapping (address => bool) public ownerList;
    // The associative mapping that maps ASNs to their owner's public key.
    mapping (uint32 => address) public ASNList;
    // List of prefixes.
    IPPrefix[] public prefixes;
    IPResource[] public ipresources;

    // Holds the table of links keyed by sha256(encodePacked(ASN1,ASN2))
    // A link is valid if both ASN1->ASN2 and ASN2->ASN1 exist.
    // This particular structure has the potential to be astoundingly large.
    mapping (bytes32 => bool) links;

    /// Simple modifier to ensure that only owners can make changes
    modifier onlyOwners {
        require(ownerList[msg.sender] == true);
        _;
    }

    constructor() public {
        // Automatically add the contract creator as an owner
        ownerList[msg.sender] = true; //owner = msg.sender    

        //Build IP resource for root resource (IANA)
        IPResource memory rootResource;
        
        // Build up the prefix for the root prefix
        IPPrefix memory rootPrefix;
        rootPrefix.ip = 0;
        rootPrefix.mask = 0;
        rootPrefix.owningAS = 0;
        prefixes.push(rootPrefix);

        rootResource.prefix = rootPrefix;
        rootResource.state = IPState.Unregistered;
        rootResource.RIR = "";      //hasn't been allocated to any RIR. owned by IANA
        rootResource.owner = "";    //hasn't been allocated to any RIR
        rootResource.leasee = "";   //hasn't been leased to anybody
        ipresources.push(rootResource);

        // Mark that the root is owned by a dummy address.
        ASNList[0] = address(0);
    }

        /// Generates the message text to be signed for add authentication.
    /// @param ASN The ASN to be added
    /// @param ASNOwner The public key of the new owner.
    /// @return bytes32 The sha256 hash of abi.encodePacked(ASN,ASNOwner).
    function IANA_getSignatureMessage(uint32 ASN, address ASNOwner) pure public returns(bytes32) {
        return sha256(abi.encodePacked(ASN,ASNOwner));
    }
   
    /// Adds an additional ASN to the ASN list. The operation has to include a signature
    /// from the ASN owner signing sha256(abi.encodePacked(ASN,ASNOwner)) which can be
    /// generated by calling IANA_getSignatureMessage()
    /// @param ASN The ASN to be added
    /// @param ASNOwner The public key of the new owner.
    /// @param sigV The V parameter of the signature.
    /// @param sigR The R parameter of the signature.
    /// @param sigS The S parameter of the signature.
    function IANA_addASN(uint32 ASN, address ASNOwner, uint8 sigV, bytes32 sigR, bytes32 sigS) public onlyOwners {
        // It must be signed by the new ASNOwner. We don't have to check for the IANA owner because
        // the onlyOwners routine does that for us.
        require(ecrecover(IANA_getSignatureMessage(ASN, ASNOwner), sigV, sigR, sigS) == ASNOwner);
        require(ASN != 0);
        
        // At this point, we have two party agreement on ASN ownership. Add it to the ANSList.
        ASNList[ASN] = ASNOwner;
    }

    //pass in signed string of IANA_getSignatureMessage. See: https://web3py.readthedocs.io/en/stable/web3.eth.account.html
    function IANA_addASNSigned(uint32 ASN, address ASNOwner, bytes32 signedSigMsg, uint8 sigV, bytes32 sigR, bytes32 sigS) public onlyOwners {
        // It must be signed by the new ASNOwner. We don't have to check for the IANA owner because
        // the onlyOwners routine does that for us.
        require(ecrecover(signedSigMsg, sigV, sigR, sigS) == ASNOwner);
        require(ASN != 0); 
     
        // At this point, we have two party agreement on ASN ownership. Add it to the ANSList.
        ASNList[ASN] = ASNOwner;
    }   


        /// Returns the owner's address for the given ASN, or 0 if no one owns the ASN.
    /// @param ASN The ASN whose owner is to be returned
    /// @return address The address of the owner.
    function IANA_getASNOwner(uint32 ASN) public view returns (address) {
        return ASNList[ASN];
    }

    /// Adds an additional user to the owners table, allowing them to modify the discovery tables.
    /// @param owner The public key of the new owner.
    function IANA_addOwner(address owner) public onlyOwners {
        ownerList[owner] = true;
    }

    /// Removes a user from the owners table, who will no longer be allowed to edit the discovery table.
    /// @param owner The public key of the owner to be removed.
    function IANA_removeOwner(address owner) public onlyOwners {
        delete(ownerList[owner]);
    }

            /// Returns the contract address of the contact that contains the desired function.
    /// @param AS1 The ASN of the first end of the link
    /// @param AS2 The ASN of the first end of the link
    /// @return bool True if there is a valid, bidirectional link from AS1 to AS2
    function link_validateLink(uint32 AS1, uint32 AS2) public view returns (bool) {
        // Make the hash for the link in the forward direction
        bytes32 linkhash1 = sha256(abi.encodePacked(AS1, AS2));
        // Make the hash for the link in the reverse direction
        bytes32 linkhash2 = sha256(abi.encodePacked(AS2, AS1));
        // Return true if both links are in the valid link table.
        return links[linkhash1] && links[linkhash2];
    }

        /// Marks that the caller believes it has a link to a particular destination ASN.
    /// @param myASN The ASN the caller owns
    /// @param destinationASN The ASN that the caller links to.
    function link_addLink(uint32 myASN, uint32 destinationASN) public {
        require(msg.sender == ASNList[myASN]);
        bytes32 linkhash = sha256(abi.encodePacked(myASN, destinationASN));
        links[linkhash] = true;
    }

        /// Marks that the caller believes it no longer has a link to a particular destination ASN.
    /// @param myASN The ASN the caller owns
    /// @param destinationASN The ASN that the caller links to.
    function link_removeLink(uint32 myASN, uint32 destinationASN) public {
        require(msg.sender == ASNList[myASN]);
        bytes32 linkhash = sha256(abi.encodePacked(myASN, destinationASN));
        links[linkhash] = false;
    }

}
